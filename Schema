- =========================================================
-- ELECTRONICS SALES & SERVICE - SEQUENCES + TRIGGERS (direct NEXTVAL assignment)
-- All triggers now use: v_seq := <seq>.NEXTVAL;
-- =========================================================
 CREATE USER marzan IDENTIFIED BY marzan
DEFAULT TABLESPACE users
TEMPORARY TABLESPACE temp
QUOTA UNLIMITED ON users
/
{{{DEFAULT TABLESPACE users → টেবিলগুলো users tablespace‑এ থাকবে।

TEMPORARY TABLESPACE temp → sort/temporary কাজের জন্য temp tablespace ব্যবহার হবে।

QUOTA UNLIMITED → এই ইউজার unlimited space ব্যবহার করতে পারবে ওই tablespace‑এ।

cre_by

কে এই রেকর্ডটি তৈরি করেছে, সেই ব্যক্তির নাম বা আইডি সংরক্ষণ করার জন্য ব্যবহৃত হয়।

cre_dt

রেকর্ডটি কবে তৈরি হয়েছে (তারিখ ও সময়) তা সংরক্ষণ করে।

upd_by

রেকর্ডটি সর্বশেষ কে আপডেট করেছে, তার নাম বা আইডি রাখে।

upd_dt

রেকর্ডটি সর্বশেষ কখন আপডেট হয়েছে, সেই সময় ও তারিখ সংরক্ষণ করে।

সংক্ষেপে:
cre_by/cre_dt = রেকর্ড তৈরি সম্পর্কিত তথ্য
upd_by/upd_dt = রেকর্ড আপডেট সম্পর্কিত তথ্য}}}}

**
GRANT CONNECT, RESOURCE TO marzan;
GRANT DBA TO marzan;






/* 1) COMPANY */
CREATE TABLE company (
    company_id          NUMBER PRIMARY KEY,
    company_name        VARCHAR2(200) NOT NULL UNIQUE,
    company_proprietor  VARCHAR2(200),
    phone_no            VARCHAR2(50) NOT NULL UNIQUE,
    email               VARCHAR2(200) NOT NULL UNIQUE,
    address             VARCHAR2(300),
    website             VARCHAR2(200) UNIQUE,
    contact_person      VARCHAR2(200),
    cp_designation      VARCHAR2(200),
    cp_phone_no         VARCHAR2(50),
    tag_line            VARCHAR2(300),
    mission_vision      VARCHAR2(1000),
    status              NUMBER,
    cre_by              VARCHAR2(100),
    cre_dt              DATE,
    upd_by              VARCHAR2(100),
    upd_dt              DATE
);
CREATE SEQUENCE company_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_company_bi
BEFORE INSERT OR UPDATE ON company
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE
    v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.company_id IS NULL THEN
            v_seq := company_seq.NEXTVAL;
            :new.company_id := v_seq;
        END IF;

        IF :new.status IS NULL THEN
            :new.status := 1;
        END IF;

        IF :new.cre_by IS NULL THEN
            :new.cre_by := NVL(V('APP_USER'), USER);
        END IF;

        IF :new.cre_dt IS NULL THEN
            :new.cre_dt := SYSDATE;
        END IF;

    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN
            :new.upd_by := NVL(V('APP_USER'), USER);
        END IF;

        IF :new.upd_dt IS NULL THEN
            :new.upd_dt := SYSDATE;
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
/
-- =========================================================

/* 2) DEPARTMENTS */
CREATE TABLE departments (
    department_id    NUMBER PRIMARY KEY,
    department_name  VARCHAR2(200),
    manager_id       NUMBER,
    company_id       NUMBER,
    status           NUMBER,
    cre_by           VARCHAR2(100),
    cre_dt           DATE,
    upd_by           VARCHAR2(100),
    upd_dt           DATE,
    CONSTRAINT fk_departments_company FOREIGN KEY (company_id) REFERENCES company(company_id)
);
CREATE SEQUENCE departments_seq START WITH 10 INCREMENT BY 10 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_departments
BEFORE INSERT OR UPDATE ON departments
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE
    v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.department_id IS NULL THEN
            v_seq := departments_seq.NEXTVAL;
            :new.department_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

CREATE TABLE jobs (
    job_id        VARCHAR2(50) PRIMARY KEY,
    job_code      VARCHAR2(50),
    job_title     VARCHAR2(200),
    job_grade     VARCHAR2(1),
    min_salary    NUMBER,
    max_salary    NUMBER,
    status        NUMBER,
    cre_by        VARCHAR2(100),
    cre_dt        DATE,
    upd_by        VARCHAR2(100),
    upd_dt        DATE,
    CONSTRAINT chk_job_grade CHECK (job_grade IN ('A','B','C') OR job_grade IS NULL),
    CONSTRAINT chk_salary_range CHECK (min_salary IS NULL OR max_salary IS NULL OR min_salary <= max_salary)
);

CREATE SEQUENCE jobs_seq START WITH 1 INCREMENT BY 5 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_jobs
BEFORE INSERT OR UPDATE ON jobs
FOR EACH ROW
DECLARE
    v_seq_val NUMBER;
    v_code    VARCHAR2(100);
BEGIN
    IF INSERTING THEN
        v_seq_val := jobs_seq.NEXTVAL;

        IF :new.job_code IS NOT NULL THEN
            v_code := UPPER(TRIM(:new.job_code));  
            :new.job_id := v_code || TO_CHAR(v_seq_val);  
        ELSE
            :new.job_id := TO_CHAR(v_seq_val);
        END IF;

        IF :new.status IS NULL THEN
            :new.status := 1;
        END IF;
        IF :new.cre_by IS NULL THEN
            :new.cre_by := NVL(V('APP_USER'), USER);
        END IF;
        IF :new.cre_dt IS NULL THEN
            :new.cre_dt := SYSDATE;
        END IF;

    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN
            :new.upd_by := NVL(V('APP_USER'), USER);
        END IF;
        IF :new.upd_dt IS NULL THEN
            :new.upd_dt := SYSDATE;
        END IF;
 
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
/
-- =========================================================

/* 4) PARTS_CATEGORY & PARTS */
CREATE TABLE parts_category (
    parts_cat_id    NUMBER PRIMARY KEY,
    parts_cat_name  VARCHAR2(200),
    status          NUMBER,
    cre_by          VARCHAR2(100),
    cre_dt          DATE,
    upd_by          VARCHAR2(100),
    upd_dt          DATE
);
CREATE SEQUENCE parts_cat_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_parts_cat_bi
BEFORE INSERT OR UPDATE ON parts_category
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.parts_cat_id IS NULL THEN
            v_seq := parts_cat_seq.NEXTVAL;
            :new.parts_cat_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE parts (
    parts_id       NUMBER PRIMARY KEY,
    parts_name     VARCHAR2(200),
    price          NUMBER,
    parts_cat_id   NUMBER,
    status         NUMBER,
    cre_by         VARCHAR2(100),
    cre_dt         DATE,
    upd_by         VARCHAR2(100),
    upd_dt         DATE,
    CONSTRAINT fk_parts_parts_cat FOREIGN KEY (parts_cat_id) REFERENCES parts_category(parts_cat_id)
);
CREATE SEQUENCE parts_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_parts_bi
BEFORE INSERT OR UPDATE ON parts
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.parts_id IS NULL THEN
            v_seq := parts_seq.NEXTVAL;
            :new.parts_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 5) PRODUCT CATEGORIES / SUB / BRAND */
CREATE TABLE product_categories (
    product_cat_id    NUMBER PRIMARY KEY,
    product_cat_name  VARCHAR2(200),
    status            NUMBER,
    cre_by            VARCHAR2(100),
    cre_dt            DATE,
    upd_by            VARCHAR2(100),
    upd_dt            DATE
);
CREATE SEQUENCE product_categories_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_product_categories_bi
BEFORE INSERT OR UPDATE ON product_categories
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.product_cat_id IS NULL THEN
            v_seq := product_categories_seq.NEXTVAL;
            :new.product_cat_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE sub_categories (
    sub_cat_id       NUMBER PRIMARY KEY,
    sub_cat_name     VARCHAR2(200),
    product_cat_id   NUMBER,
    status           NUMBER,
    cre_by           VARCHAR2(100),
    cre_dt           DATE,
    upd_by           VARCHAR2(100),
    upd_dt           DATE,
    CONSTRAINT fk_subcat_productcat FOREIGN KEY (product_cat_id) REFERENCES product_categories(product_cat_id)
);
CREATE SEQUENCE sub_categories_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sub_categories_bi
BEFORE INSERT OR UPDATE ON sub_categories
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.sub_cat_id IS NULL THEN
            v_seq := sub_categories_seq.NEXTVAL;
            :new.sub_cat_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE brand (
    brand_id     NUMBER PRIMARY KEY,
    brand_name   VARCHAR2(200),
    model_name   VARCHAR2(200),
    size         VARCHAR2(50),
    color        VARCHAR2(100),
    status       NUMBER,
    cre_by       VARCHAR2(100),
    cre_dt       DATE,
    upd_by       VARCHAR2(100),
    upd_dt       DATE
);
CREATE SEQUENCE brand_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_brand_bi
BEFORE INSERT OR UPDATE ON brand
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.brand_id IS NULL THEN
            v_seq := brand_seq.NEXTVAL;
            :new.brand_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 6) SUPPLIERS */
CREATE TABLE suppliers (
    supplier_id NUMBER PRIMARY KEY,
    supplier_name VARCHAR2(200) NOT NULL,
    phone_no VARCHAR2(50),
    email VARCHAR2(200),
    address VARCHAR2(300),
    contact_person VARCHAR2(200),
    cp_phone_no VARCHAR2(50),
    cp_email VARCHAR2(200),
    purchase_total NUMBER DEFAULT 0,
    pay_total NUMBER DEFAULT 0,
    due NUMBER GENERATED ALWAYS AS (NVL(purchase_total,0) - NVL(pay_total,0)) VIRTUAL,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE
);
CREATE SEQUENCE suppliers_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_suppliers_bi
BEFORE INSERT OR UPDATE ON suppliers
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.supplier_id IS NULL THEN
            v_seq := suppliers_seq.NEXTVAL;
            :new.supplier_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 7) PRODUCTS */
CREATE TABLE products (
    product_id        NUMBER PRIMARY KEY,
    product_code      VARCHAR2(50) UNIQUE,
    product_name      VARCHAR2(200) NOT NULL,
    supplier_id       NUMBER,
    category_id       NUMBER,
    subcategory_id    NUMBER,
    brand_id          NUMBER,
    uom               VARCHAR2(50),
    mrp               NUMBER,
    purchase_price    NUMBER,
    warranty_24_12    VARCHAR2(10),
    status            VARCHAR2(50),
    status_num        NUMBER,
    cre_by            VARCHAR2(100),
    cre_dt            DATE,
    upd_by            VARCHAR2(100),
    upd_dt            DATE,
    CONSTRAINT fk_products_supplier FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id),
    CONSTRAINT fk_products_category FOREIGN KEY (category_id) REFERENCES product_categories(product_cat_id),
    CONSTRAINT fk_products_subcategory FOREIGN KEY (subcategory_id) REFERENCES sub_categories(sub_cat_id),
    CONSTRAINT fk_products_brand FOREIGN KEY (brand_id) REFERENCES brand(brand_id)
);
CREATE SEQUENCE products_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_products_bi
BEFORE INSERT OR UPDATE ON products
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.product_id IS NULL THEN
            v_seq := products_seq.NEXTVAL;
            :new.product_id := v_seq;
        END IF;
        IF :new.status_num IS NULL THEN :new.status_num := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 8) STOCK */
CREATE TABLE stock (
    stock_id         NUMBER PRIMARY KEY,
    product_id       NUMBER,
    supplier_id      NUMBER,
    product_cat_id   NUMBER,
    sub_cat_id       NUMBER,
    quantity         NUMBER DEFAULT 0,
    last_update      TIMESTAMP DEFAULT SYSTIMESTAMP,
    status           NUMBER,
    cre_by           VARCHAR2(100),
    cre_dt           DATE,
    upd_by           VARCHAR2(100),
    upd_dt           DATE,
    CONSTRAINT fk_stock_product FOREIGN KEY (product_id) REFERENCES products(product_id),
    CONSTRAINT fk_stock_supplier FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id),
    CONSTRAINT fk_stock_product_cat FOREIGN KEY (product_cat_id) REFERENCES product_categories(product_cat_id),
    CONSTRAINT fk_stock_sub_cat FOREIGN KEY (sub_cat_id) REFERENCES sub_categories(sub_cat_id)
);
CREATE SEQUENCE stock_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_stock_bi
BEFORE INSERT OR UPDATE ON stock
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.stock_id IS NULL THEN
            v_seq := stock_seq.NEXTVAL;
            :new.stock_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 9) EMPLOYEES */
CREATE TABLE employees (
    employee_id    NUMBER PRIMARY KEY,
    first_name     VARCHAR2(100),
    last_name      VARCHAR2(100),
    email          VARCHAR2(200),
    phone_no       VARCHAR2(50),
    address        VARCHAR2(4000),
    hire_date      DATE,
    salary         NUMBER,
    job_id         NUMBER,
    manager_id     NUMBER,
    department_id  NUMBER,
    photo          BLOB,
    status         NUMBER,
    cre_by         VARCHAR2(100),
    cre_dt         DATE,
    upd_by         VARCHAR2(100),
    upd_dt         DATE,
    CONSTRAINT fk_employees_job FOREIGN KEY (job_id) REFERENCES jobs(job_id),
    CONSTRAINT fk_employees_manager FOREIGN KEY (manager_id) REFERENCES employees(employee_id),
    CONSTRAINT fk_employees_department FOREIGN KEY (department_id) REFERENCES departments(department_id)
);
CREATE SEQUENCE employees_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_employees_bi
BEFORE INSERT OR UPDATE ON employees
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.employee_id IS NULL THEN
            v_seq := employees_seq.NEXTVAL;
            :new.employee_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 10) USERS */
CREATE TABLE users (
    user_id NUMBER PRIMARY KEY,
    user_name VARCHAR2(100) NOT NULL UNIQUE,
    password VARCHAR2(200) NOT NULL,
    role VARCHAR2(50) DEFAULT 'user' NOT NULL,
    employee_id NUMBER,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_users_employee FOREIGN KEY (employee_id) REFERENCES employees(employee_id) ON DELETE SET NULL,
    CONSTRAINT chk_password_len CHECK (LENGTH(password) >= 8)
);
CREATE SEQUENCE users_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_users_bi
BEFORE INSERT OR UPDATE ON users
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.user_id IS NULL THEN
            v_seq := users_seq.NEXTVAL;
            :new.user_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 11) CUSTOMERS (audit trigger only) */
CREATE TABLE customers (
    phone_no VARCHAR2(50) PRIMARY KEY,
    customer_name VARCHAR2(200) NOT NULL,
    alt_phone_no VARCHAR2(50),
    email VARCHAR2(200),
    address VARCHAR2(300),
    city VARCHAR2(100),
    rewards VARCHAR2(100),
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE
);

CREATE OR REPLACE TRIGGER trg_customers_bi
BEFORE INSERT OR UPDATE ON customers
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 12) PAYMENTS */
CREATE TABLE payments (
    payment_id NUMBER PRIMARY KEY,
    payment_date DATE NOT NULL,
    amount NUMBER NOT NULL CHECK (amount > 0),
    payment_type VARCHAR2(50) NOT NULL,
    supplier_id NUMBER,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_payments_supplier FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id)
);
CREATE SEQUENCE payments_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_payments_bi
BEFORE INSERT OR UPDATE ON payments
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.payment_id IS NULL THEN
            v_seq := payments_seq.NEXTVAL;
            :new.payment_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 13) SERVICE LIST / MASTER / DETAILS */
CREATE TABLE service_list (
    servicelist_id NUMBER PRIMARY KEY,
    service_name VARCHAR2(200) NOT NULL,
    service_desc VARCHAR2(1000),
    service_cost NUMBER DEFAULT 0,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE
);
CREATE SEQUENCE service_list_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_service_list_bi
BEFORE INSERT OR UPDATE ON service_list
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.servicelist_id IS NULL THEN
            v_seq := service_list_seq.NEXTVAL;
            :new.servicelist_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE service_master (
    service_id NUMBER PRIMARY KEY,
    service_date DATE DEFAULT SYSDATE,
    customer_phone VARCHAR2(50),
    invoice_id NUMBER,
    warranty_applicable CHAR(1),
    servicelist_id NUMBER,
    service_by NUMBER,
    service_charge NUMBER DEFAULT 0,
    parts_price NUMBER DEFAULT 0,
    total_price NUMBER GENERATED ALWAYS AS (NVL(service_charge,0) + NVL(parts_price,0)) VIRTUAL,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_service_customer FOREIGN KEY (customer_phone) REFERENCES customers(phone_no),
    CONSTRAINT fk_service_list FOREIGN KEY (servicelist_id) REFERENCES service_list(servicelist_id),
    CONSTRAINT fk_service_by FOREIGN KEY (service_by) REFERENCES employees(employee_id)
);
CREATE SEQUENCE service_master_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_service_master_bi
BEFORE INSERT OR UPDATE ON service_master
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.service_id IS NULL THEN
            v_seq := service_master_seq.NEXTVAL;
            :new.service_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE service_details (
    service_det_id NUMBER PRIMARY KEY,
    service_id NUMBER,
    parts_id NUMBER,
    price NUMBER,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_sd_service FOREIGN KEY (service_id) REFERENCES service_master(service_id),
    CONSTRAINT fk_sd_parts FOREIGN KEY (parts_id) REFERENCES parts(parts_id)
);
CREATE SEQUENCE service_details_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_service_details_bi
BEFORE INSERT OR UPDATE ON service_details
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.service_det_id IS NULL THEN
            v_seq := service_details_seq.NEXTVAL;
            :new.service_det_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 14) SALES MASTER / DETAIL / RETURN */
CREATE TABLE sales_master (
    invoice_id NUMBER PRIMARY KEY,
    invoice_date DATE DEFAULT SYSDATE,
    total_amount NUMBER DEFAULT 0,
    discount NUMBER DEFAULT 0,
    adjust_ref NUMBER,
    adjust_amount NUMBER DEFAULT 0,
    grand_total NUMBER GENERATED ALWAYS AS (NVL(total_amount,0) - NVL(discount,0) - NVL(adjust_amount,0)) VIRTUAL,
    payment_type VARCHAR2(50),
    customer_phone VARCHAR2(50),
    sales_by NUMBER,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_sales_customer FOREIGN KEY (customer_phone) REFERENCES customers(phone_no),
    CONSTRAINT fk_sales_by FOREIGN KEY (sales_by) REFERENCES employees(employee_id)
);
CREATE SEQUENCE sales_master_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sales_master_bi
BEFORE INSERT OR UPDATE ON sales_master
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.invoice_id IS NULL THEN
            v_seq := sales_master_seq.NEXTVAL;
            :new.invoice_id := v_seq;
        END IF;
        IF :new.status IS NULL THEN :new.status := 1; END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE sales_detail (
    sales_det_id NUMBER PRIMARY KEY,
    invoice_id NUMBER,
    product_id NUMBER,
    unit_price NUMBER,
    quantity NUMBER,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_sd_invoice FOREIGN KEY (invoice_id) REFERENCES sales_master(invoice_id),
    CONSTRAINT fk_sd_product FOREIGN KEY (product_id) REFERENCES products(product_id)
);
CREATE SEQUENCE sales_detail_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sales_detail_bi
BEFORE INSERT OR UPDATE ON sales_detail
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.sales_det_id IS NULL THEN
            v_seq := sales_detail_seq.NEXTVAL;
            :new.sales_det_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE sales_return_master (
    sales_return_id NUMBER PRIMARY KEY,
    invoice_id NUMBER,
    customer_phone VARCHAR2(50),
    return_date DATE DEFAULT SYSDATE,
    total_amount NUMBER DEFAULT 0,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_sr_invoice FOREIGN KEY (invoice_id) REFERENCES sales_master(invoice_id),
    CONSTRAINT fk_sr_customer FOREIGN KEY (customer_phone) REFERENCES customers(phone_no)
);
CREATE SEQUENCE sales_return_master_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sales_return_master_bi
BEFORE INSERT OR UPDATE ON sales_return_master
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.sales_return_id IS NULL THEN
            v_seq := sales_return_master_seq.NEXTVAL;
            :new.sales_return_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE sales_return_details (
    sales_return_det_id NUMBER PRIMARY KEY,
    sales_return_id NUMBER,
    product_id NUMBER,
    unit_price NUMBER,
    qty_return NUMBER,
    reason VARCHAR2(4000),
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_srd_master FOREIGN KEY (sales_return_id) REFERENCES sales_return_master(sales_return_id),
    CONSTRAINT fk_srd_product FOREIGN KEY (product_id) REFERENCES products(product_id)
);
CREATE SEQUENCE sales_return_details_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_sales_return_details_bi
BEFORE INSERT OR UPDATE ON sales_return_details
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.sales_return_det_id IS NULL THEN
            v_seq := sales_return_details_seq.NEXTVAL;
            :new.sales_return_det_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

/* 15) PRODUCT ORDER / RECEIVE / RETURN / DAMAGE */
CREATE TABLE product_order_master (
    order_id NUMBER PRIMARY KEY,
    supplier_id NUMBER,
    order_date DATE DEFAULT SYSDATE,
    expected_delivery_date DATE,
    total_amount NUMBER DEFAULT 0,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    created_by NUMBER,
    status NUMBER,
    CONSTRAINT fk_pom_supplier FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id)
);
CREATE SEQUENCE product_order_master_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_product_order_master_bi
BEFORE INSERT OR UPDATE ON product_order_master
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.order_id IS NULL THEN
            v_seq := product_order_master_seq.NEXTVAL;
            :new.order_id := v_seq;
        END IF;
        -- created_by left to application if provided
    ELSIF UPDATING THEN
        NULL;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE product_order_detail (
    order_detail_id NUMBER PRIMARY KEY,
    order_id NUMBER,
    product_id NUMBER,
    unit_price NUMBER,
    quantity NUMBER,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_pod_order FOREIGN KEY (order_id) REFERENCES product_order_master(order_id),
    CONSTRAINT fk_pod_product FOREIGN KEY (product_id) REFERENCES products(product_id)
);
CREATE SEQUENCE product_order_detail_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_product_order_detail_bi
BEFORE INSERT OR UPDATE ON product_order_detail
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.order_detail_id IS NULL THEN
            v_seq := product_order_detail_seq.NEXTVAL;
            :new.order_detail_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE product_receive_master (
    receive_id NUMBER PRIMARY KEY,
    invoice_id NUMBER,
    order_id NUMBER,
    supplier_id NUMBER,
    receive_date DATE DEFAULT SYSDATE,
    total_amount NUMBER DEFAULT 0,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    created_by NUMBER,
    status NUMBER
);
CREATE SEQUENCE product_receive_master_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_product_receive_master_bi
BEFORE INSERT OR UPDATE ON product_receive_master
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.receive_id IS NULL THEN
            v_seq := product_receive_master_seq.NEXTVAL;
            :new.receive_id := v_seq;
        END IF;
    ELSIF UPDATING THEN
        NULL;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE product_receive_details (
    receive_det_id NUMBER PRIMARY KEY,
    receive_id NUMBER,
    product_id NUMBER,
    unit_price NUMBER,
    receive_quantity NUMBER,
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_prd_master FOREIGN KEY (receive_id) REFERENCES product_receive_master(receive_id),
    CONSTRAINT fk_prd_product FOREIGN KEY (product_id) REFERENCES products(product_id)
);
CREATE SEQUENCE product_receive_details_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_product_receive_details_bi
BEFORE INSERT OR UPDATE ON product_receive_details
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.receive_det_id IS NULL THEN
            v_seq := product_receive_details_seq.NEXTVAL;
            :new.receive_det_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE product_return_master (
    return_id NUMBER PRIMARY KEY,
    supplier_id NUMBER,
    return_date DATE DEFAULT SYSDATE,
    total_amount NUMBER DEFAULT 0,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    created_by NUMBER,
    status NUMBER
);
CREATE SEQUENCE product_return_master_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_product_return_master_bi
BEFORE INSERT OR UPDATE ON product_return_master
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.return_id IS NULL THEN
            v_seq := product_return_master_seq.NEXTVAL;
            :new.return_id := v_seq;
        END IF;
    ELSIF UPDATING THEN
        NULL;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE product_return_details (
    return_detail_id NUMBER PRIMARY KEY,
    return_id NUMBER,
    product_id NUMBER,
    unit_price NUMBER,
    return_quality VARCHAR2(100),
    reason VARCHAR2(1000),
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_prd2_master FOREIGN KEY (return_id) REFERENCES product_return_master(return_id),
    CONSTRAINT fk_prd2_product FOREIGN KEY (product_id) REFERENCES products(product_id)
);
CREATE SEQUENCE product_return_details_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_product_return_details_bi
BEFORE INSERT OR UPDATE ON product_return_details
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.return_detail_id IS NULL THEN
            v_seq := product_return_details_seq.NEXTVAL;
            :new.return_detail_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE damage (
    damage_id NUMBER PRIMARY KEY,
    damage_date DATE DEFAULT SYSDATE,
    total_amount NUMBER DEFAULT 0,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    created_by NUMBER,
    status NUMBER
);
CREATE SEQUENCE damage_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_damage_bi
BEFORE INSERT OR UPDATE ON damage
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.damage_id IS NULL THEN
            v_seq := damage_seq.NEXTVAL;
            :new.damage_id := v_seq;
        END IF;
    ELSIF UPDATING THEN
        NULL;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/

CREATE TABLE damage_detail (
    damage_detail_id NUMBER PRIMARY KEY,
    damage_id NUMBER,
    product_id NUMBER,
    unit_price NUMBER,
    damage_quantity NUMBER,
    reason VARCHAR2(1000),
    status NUMBER,
    cre_by VARCHAR2(100),
    cre_dt DATE,
    upd_by VARCHAR2(100),
    upd_dt DATE,
    CONSTRAINT fk_damaged_master FOREIGN KEY (damage_id) REFERENCES damage(damage_id),
    CONSTRAINT fk_damaged_product FOREIGN KEY (product_id) REFERENCES products(product_id)
);
CREATE SEQUENCE damage_detail_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE TRIGGER trg_damage_detail_bi
BEFORE INSERT OR UPDATE ON damage_detail
REFERENCING NEW AS new OLD AS old
FOR EACH ROW
DECLARE v_seq NUMBER;
BEGIN
    IF INSERTING THEN
        IF :new.damage_detail_id IS NULL THEN
            v_seq := damage_detail_seq.NEXTVAL;
            :new.damage_detail_id := v_seq;
        END IF;
        IF :new.cre_by IS NULL THEN :new.cre_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.cre_dt IS NULL THEN :new.cre_dt := SYSDATE; END IF;
    ELSIF UPDATING THEN
        IF :new.upd_by IS NULL THEN :new.upd_by := NVL(V('APP_USER'), USER); END IF;
        IF :new.upd_dt IS NULL THEN :new.upd_dt := SYSDATE; END IF;
    END IF;
EXCEPTION WHEN OTHERS THEN RAISE;
END;
/
-- =========================================================

COMMIT;
